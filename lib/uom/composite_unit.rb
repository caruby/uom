require 'singleton'
require 'generator'
require 'extensional'
require 'active_support/inflector'
require 'uom/unit'
require 'uom/composite_unit_key_canonicalizer'

module UOM
   # A CompositeUnit represents a measurement unit across more than one dimension, e.g. +:gram_per_liter+.
  class CompositeUnit < Unit
    SUPPORTED_OPERATORS = [:/, :*]

    @canonicalizer = CompositeUnitKeyCanonicalizer.new

    make_extensional(Hash.new { |hash, spec| match(hash, *spec) }) do |hash, unit|
      key = @canonicalizer.canonicalize(unit.axes.first, unit.axes.last, unit.operator)
      hash[key] = unit
    end

    attr_reader :operator, :axes

    # Creates a CompositeUnit from the given units u1 and u2 and operator symbol +:/+ or +:*+.
    # Each unit can be either a Unit or another CompositeUnit.
    # The remaining parameters are described in Unit.
    #
    # The CompositeUnit label is inferred from the operator constituent units, e.g.:
    #   CompositeUnit.new(Unit.for(:gram), Unit.for(:liter), :/) #=> grams_per_liter
    def initialize(u1, u2, operator, *params)
      @axes = [u1, u2]
      @operator = operator
      raise MeasurementError.new("Unit composition operator unsupported - expected #{SUPPORTED_OPERATORS.join(' or ')}, found #{operator}") unless SUPPORTED_OPERATORS.include?(operator)
      # make the composite dimension parameter
      dims = @axes.map { |axis| axis.dimension }
      # Add the first axis and the dimension to the parameters. The first axis is designated
      # the axis in Unit; the second axis is a qualifier.
      params << CompositeDimension.for([dims, @operator])
      # call the Unit initializer with the parameters except for the axes
      super(*params)
      # add to the extent
      CompositeUnit << self
    end

    # Returns the the given quantity converted from this Unit into the given unit.
    def as(quantity, unit)
      # if unit wraps a composite unit axis, then convert unit => axis => self and invert
      return 1.0 / unit.as(1.0 / quantity, self) unless CompositeUnit === unit
      raise MeasurementError.new("No conversion from #{self} to #{unit}") unless unit.axes.size == axes.size and unit.operator == operator
      # convert the the first axis quantity to the first unit axis
      first = axes[0].as(quantity, unit.axes[0])
      # convert the remaining units
      vector = SyncEnumerator.new(axes[1..-1], unit.axes[1..-1]).map { |from, to| from.as(1, to).to_f }
      # apply the operator
      vector.inject(first) { |q, item| q.send(@operator, item) }
    end

    def to_s(quantity=nil)
      @operator == :* ? super : [axes.first.to_s(quantity)].concat(axes[1..-1]).join('_per_')
    end

    def inspect
      "#{self.class.name}@#{self.object_id}[#{([label] + abbreviations).join(', ')}: #{composition_to_s}]"
    end

    # Returns a string representation of this CompositeUnit's composition, e.g.
    #   ((UOM::METER * UOM::SECOND) / UOM::GRAM).composition_to_s #=> (meter * second) / gram
    def composition_to_s
      axes.map { |axis| CompositeUnit === axis ? "(#{axis.composition_to_s})" : axis.label.to_s }.join(" #{operator} ")
    end

    protected

    def create_label
      case @operator
      when :/ then create_division_label
      when :* then create_product_label
      end
    end

    private

    # Returns the CompositeUnit which matches the key [u1, u2, operator] in hash. If there is no such key
    # in hash, then match on the canonicalized form of [u1, u2, operator]. Creates a new CompositeUnit from
    # the canonical form if there is no match.
    def self.match(hash, u1, u2, operator)
      # canonicalize the arguments into the form [cu1, cu2, op], where cu2 is a non-composite unit and
      # cu1 is either a composite or a non-composite unit and op is an unit product or quotient operator.
      # the locator block recursively matches a sub-specification generated by the canonicalizer.
      spec = @canonicalizer.canonicalize(u1, u2, operator) { |spec| hash[spec] }
      # if there is a match on the canonicalized spec [cu1, cu2, op], then return the match.
      # otherwise, make a new CompositeUnit from cu1, cu2 and op.
      hash.has_key?(spec) ? hash[spec] : new(*spec)
    end

    def create_division_label
      [axes.first.label.to_s.pluralize].concat(axes[1..-1].map { |unit| unit.label.to_s }).join('_per_').to_sym
    end

    def create_product_label
      # unit * unit has label square_unit
      label = axes.first == axes.last ? "square_#{axes.first.label}" : "#{axes.first.label}_#{axes.last.label}"
      # convert square_unit_unit to cubic_unit
      label.gsub(/square_([[:alnum:]]+)_\1/, 'cubic_\1').to_sym
    end
  end
end